// -*- mode: C++ -*-
// This file is part of HemeLB and is Copyright (C)
// the HemeLB team and/or their institutions, as detailed in the
// file AUTHORS. This software is provided under the terms of the
// license in the file LICENSE.

#ifndef HEMELB_UNITTESTS_IO_XDRWRITERTESTS_H
#define HEMELB_UNITTESTS_IO_XDRWRITERTESTS_H

#include <cppunit/TestFixture.h>
#include <type_traits>

#include "io/writers/xdr/XdrWriter.h"
// This header is generated by xdr_gen.py
#include "unittests/io/xdr_test_data.h"

namespace hemelb
{
  namespace unittests
  {
    namespace io
    {
      
      class XdrWriterTests : public CppUnit::TestFixture
      {
	CPPUNIT_TEST_SUITE(XdrWriterTests);
	CPPUNIT_TEST(TestInt32);
	CPPUNIT_TEST(TestUInt32);
	CPPUNIT_TEST(TestInt64);
	CPPUNIT_TEST(TestUInt64);

	CPPUNIT_TEST(TestFloat);
	CPPUNIT_TEST(TestDouble);

	CPPUNIT_TEST(TestString);
	CPPUNIT_TEST_SUITE_END();

	using buf_t = std::vector<char>;

	template<typename T>
	void TestBasic(const std::vector<T>& values, const std::vector<char>& expected_buffer) {
	  // Figure out sizes and counts
	  constexpr auto sz = sizeof(T);
	  static_assert(sz > 0 && sz <= 8,
			"Only works on 8--64 bit types");
	  constexpr auto type_bits = sz*8;
	  // XDR works on 32 bit words
	  constexpr auto coded_words = (sz - 1)/4 + 1;
	  constexpr auto coded_bytes = coded_words * 4;
	  // Need a value for each bit being on + zero
	  constexpr auto n_vals = type_bits + 1;
	  // Buffers for the encoded data
	  constexpr auto buf_size = n_vals * coded_bytes;
	  char our_buf[buf_size];
	  // Fill with binary ones to trigger failure if we're not
	  // writing enough zeros
	  std::fill(our_buf, our_buf+buf_size, ~'\0');

	  auto our_coder = hemelb::io::MakeXdrWriter(our_buf, our_buf + buf_size);
	  
	  CPPUNIT_ASSERT_EQUAL(n_vals, values.size());
	  for (auto& val: values) {
	    our_coder << val;
	  }
	  
	  CPPUNIT_ASSERT_EQUAL(buf_size, expected_buffer.size());
	  for (auto i = 0U; i < buf_size; ++i) {
	    CPPUNIT_ASSERT_EQUAL(expected_buffer[i], our_buf[i]);
	  }
	}

	// Flip every bit in the range in turn and check it encodes to
	// the same as libc's xdr_encode. Works only for 1- or 2-word
	// encoded size types.
	template<typename INT>
	void TestInt() {
	  static_assert(std::is_integral<INT>::value, "only works on (u)ints");
	  auto&& values = test_data<INT>::unpacked();
	  auto&& expected_buffer = test_data<INT>::packed();
	  TestBasic(values, expected_buffer);
	}

	template<typename FLOAT>
	void TestFloating() {
	  static_assert(std::is_floating_point<FLOAT>::value, "Floats only please!");

	  auto&& values = test_data<FLOAT>::unpacked();
	  auto&& expected_buffer = test_data<FLOAT>::packed();
	  
	  constexpr bool is_double = sizeof(FLOAT) == 8;
	  CPPUNIT_ASSERT_EQUAL(FLOAT(0.0), values[0]);
	  constexpr auto sign_bit = sizeof(FLOAT)*8 - 1;
	  CPPUNIT_ASSERT_EQUAL(-FLOAT(0.0), values[sign_bit + 1]);

	  CPPUNIT_ASSERT_EQUAL(std::numeric_limits<FLOAT>::denorm_min(), values[1]);

	  constexpr size_t mantissa_bits = is_double ? 52 : 23;
	  CPPUNIT_ASSERT_EQUAL(std::numeric_limits<FLOAT>::min(), values[mantissa_bits+1]);
	  TestBasic(values, expected_buffer);
	}

      public:
	void TestInt32() {
	  TestInt<int32_t>();
	}
	void TestUInt32() {
	  TestInt<uint32_t>();
	}
	void TestInt64() {
	  TestInt<int64_t>();
	}
	void TestUInt64() {
	  TestInt<uint64_t>();
	}

	void TestFloat() {
	  TestFloating<float>();
	}
	void TestDouble() {
	  TestFloating<double>();
	}

	void TestString() {
	  using UPC = std::unique_ptr<char[]>;
	  auto make_ones = [](size_t n) -> UPC {
	    // Fill with binary ones to trigger failure if we're not
	    // writing enough zeros
	    auto ans = UPC(new char[n]);
	    std::fill(ans.get(), ans.get() + n, ~'\0');
	    return ans;
	  };

	  // XDR strings are serialised as length, data (0-padded to a word)
	  auto coded_length = [](const std::string& s) {
	    return s.size() ? 4U * (2U + (s.size() - 1U) / 4U) : 4U;
	  };

	  auto&& values = test_data<std::string>::unpacked();
	  auto&& expected_buffer = test_data<std::string>::packed();

	  std::size_t total_length = 0;
	  std::for_each(
	    values.begin(), values.end(),
	    [&](const std::string& v) {
	      total_length += coded_length(v);
	    });
	  CPPUNIT_ASSERT_EQUAL(expected_buffer.size(), total_length);

	  auto our_buf = make_ones(total_length);
	  auto our_coder = hemelb::io::MakeXdrWriter(our_buf.get(), our_buf.get() + total_length);

	  for (auto& v: values) {
	    our_coder << v;
	  }
	  for (auto i = 0U; i < total_length; ++i) {
	    CPPUNIT_ASSERT_EQUAL(expected_buffer[i], our_buf[i]);
	  }
	}
      private:
      };
      CPPUNIT_TEST_SUITE_REGISTRATION(XdrWriterTests);
    }
  }
}

#endif
